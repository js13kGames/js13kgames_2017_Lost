{"version":3,"sources":["webpack:///webpack/bootstrap 582e7888d12cb265fdd1","webpack:///./src/index.js","webpack:///./src/myShader.js","webpack:///./src/map2.js","webpack:///./src/comp-map.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;ACtCA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACZA;AACA;AACA,YAAW,SAAS,gBAAgB,OAAO,WAAW,EAAE;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe,aAAa;AAC5B,iBAAgB,WAAW;AAC3B,0BAAyB,wDAAwD;AACjF,iBAAgB,qCAAqC;AACrD,4BAA2B,SAAS,iBAAiB,EAAE;AACvD,kBAAiB,SAAS,iBAAiB;AAC3C,QAAO;AACP;AACA;AACA,MAAK;AACL;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,kD;AACA;AACA,EAAC,C;;;;;;;AChDD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,wBAAuB,QAAQ;AAC/B;AACA,4BAA2B,kBAAkB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB,mBAAmB;AAC1C,+BAA8B;AAC9B;AACA,4BAA2B,sBAAsB;AACjD,gCAA+B,sBAAsB;AACrD;AACA,+CAA8C,aAAa;AAC3D;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAA+B,wBAAwB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAa;AACb;AACA;AACA,kCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qCAAoC,mCAAmC;AACvE;AACA,kBAAiB;AACjB,cAAa;AACb;AACA;AACA;AACA,uBAAsB,mCAAmC;AACzD,wBAAuB,WAAW;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;;AAEA;AACA;;AAEA;AACA,4B;;;;;;AC9OA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,0DAAyD,oBAAoB;AAC7E;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG,E","file":"b.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 582e7888d12cb265fdd1","require('./myShader.js');\r\nrequire('./comp-map');\r\n\r\nconst mapGen = require(\"./map2\");\r\n\r\ndocument.onload = function () {\r\n    let map = mapGen.go();\r\n    let scene = document.getElementById('scene');\r\n    let plane = document.createElement(\"a-entity\")\r\n    plane.setAttribute('position', \"1 1 0\");\r\n    plane.setAttribute('mixin', 'voxel');\r\n    scene.appendChild(plane);\r\n}\r\n\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/index.js\n// module id = 0\n// module chunks = 0","/* global THREE, AFRAME */\r\nAFRAME.registerComponent('material-texture', {\r\n  schema: { color: { type: 'color' }, src:{type:'map'} },\r\n  /**\r\n   * Creates a new THREE.ShaderMaterial using the two shaders defined\r\n   * in vertex.glsl and fragment.glsl.\r\n   */\r\n  init: function () {\r\n    const data = this.data;\r\n    var fragmentShader = document.getElementById('fragment').textContent;\r\n    var vertexShader = document.getElementById('vertex').textContent;\r\n    this.material = new THREE.ShaderMaterial({\r\n      uniforms: {\r\n        time: { value: 0.0 },\r\n        index: { value: 0 },\r\n        DiffuseTexture: { value: new THREE.ImageUtils.loadTexture('./lost.png') },\r\n        color: { value: new THREE.Color(data.color) },\r\n        spriteDimensions: { value: { x: 8.0, y: 1.0 } },\r\n        repeat: { value: { x: 8.0, y: 8.0 } }\r\n      },\r\n      vertexShader,\r\n      fragmentShader\r\n    });\r\n    this.applyToMesh();\r\n    this.el.addEventListener('model-loaded', () => this.applyToMesh());\r\n  },\r\n  /**\r\n   * Update the ShaderMaterial when component data changes.\r\n   */\r\n  update: function () {\r\n    // this.material.uniforms.color.value.set(this.data.color);\r\n  },\r\n  /**\r\n   * Apply the material to the current entity.\r\n   */\r\n  applyToMesh: function () {\r\n    const mesh = this.el.getObject3D('mesh');\r\n    if (mesh) {\r\n      this.material.uniforms.repeat.value.x =+this.el.getAttribute(\"width\");\r\n      this.material.uniforms.repeat.value.y =+this.el.getAttribute(\"height\");\r\n      mesh.material = this.material;\r\n    }\r\n  },\r\n  /**\r\n   * On each frame, update the 'time' uniform in the shaders.\r\n   */\r\n  tick: function (t) {\r\n    this.material.uniforms.time.value = t / 1000; \r\n  }\r\n})\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/myShader.js\n// module id = 1\n// module chunks = 0","\r\nvar generator = {\r\n    go: () => {\r\n        var pieces = [\r\n            [\r\n                [0, 0, 2, 0, 0],\r\n                [2, 1, 1, 1, 0],\r\n                [0, 1, 1, 1, 0],\r\n                [0, 1, 0, 1, 2],\r\n                [0, 0, 0, 2, 0]\r\n            ],\r\n            [\r\n                [0, 0, 2, 0, 0],\r\n                [0, 1, 1, 1, 0],\r\n                [0, 1, 0, 1, 0],\r\n                [2, 1, 0, 1, 2],\r\n                [0, 1, 1, 1, 0],\r\n                [0, 1, 1, 1, 0],\r\n                [0, 0, 2, 0, 0]\r\n            ],\r\n            [\r\n                [0, 0, 2, 0, 0],\r\n                [0, 1, 1, 1, 1],\r\n                [0, 1, 1, 1, 0],\r\n                [2, 1, 1, 1, 2],\r\n                [0, 1, 1, 1, 0],\r\n                [1, 1, 1, 1, 0],\r\n                [1, 0, 2, 0, 0]\r\n            ],\r\n            [\r\n                [0, 1, 1, 1, 0],\r\n                [2, 1, 1, 1, 0],\r\n                [0, 1, 0, 1, 0],\r\n                [0, 1, 0, 1, 2],\r\n                [0, 1, 1, 1, 0]\r\n            ],\r\n            [\r\n                [0, 0, 0, 0],\r\n                [2, 1, 1, 2],\r\n                [0, 0, 0, 0],\r\n            ],\r\n            [\r\n                [0, 2, 0],\r\n                [0, 1, 0],\r\n                [0, 1, 0],\r\n                [0, 2, 0],\r\n            ],\r\n            [\r\n                [0, 0, 0, 0, 0, 0, 0, 0],\r\n                [2, 1, 1, 1, 1, 1, 1, 2],\r\n                [0, 0, 0, 0, 0, 0, 0, 0],\r\n            ],\r\n            [\r\n                [0, 2, 0],\r\n                [0, 1, 0],\r\n                [0, 1, 0],\r\n                [0, 1, 0],\r\n                [0, 1, 0],\r\n                [0, 1, 0],\r\n                [0, 1, 0],\r\n                [0, 2, 0],\r\n            ],\r\n            [\r\n                [0, 0, 0, 0, 2, 0],\r\n                [0, 0, 0, 1, 1, 0],\r\n                [2, 1, 1, 1, 1, 0],\r\n                [0, 1, 1, 0, 1, 1],\r\n                [0, 1, 0, 0, 1, 1],\r\n                [0, 0, 1, 1, 1, 2],\r\n                [0, 1, 1, 0, 1, 0],\r\n                [0, 0, 0, 0, 2, 0],\r\n            ],\r\n            [\r\n                [0, 0, 0, 2, 0, 0],\r\n                [0, 0, 0, 1, 0, 0],\r\n                [0, 0, 0, 1, 0, 0],\r\n                [2, 1, 1, 1, 1, 2],\r\n                [0, 0, 0, 1, 0, 0],\r\n                [0, 0, 0, 1, 0, 0],\r\n                [0, 0, 0, 1, 0, 0],\r\n                [0, 0, 0, 2, 0, 0],\r\n            ],\r\n            [\r\n                [0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0],\r\n                [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0],\r\n                [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0],\r\n                [2, 1, 1, 1, 1, 0, 1, 1, 2, 0, 0],\r\n                [0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0],\r\n                [0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0],\r\n                [0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0],\r\n                [0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0],\r\n                [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2],\r\n                [0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0],\r\n                [0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0],\r\n                [0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0],\r\n                [0, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0],\r\n            ],\r\n            [\r\n                [0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0],\r\n                [0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0],\r\n                [0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0],\r\n                [0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0],\r\n                [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0],\r\n                [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0],\r\n                [2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2],\r\n                [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0],\r\n                [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2],\r\n                [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0],\r\n                [1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0],\r\n                [1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0],\r\n                [0, 0, 2, 0, 0, 0, 0, 1, 1, 0, 0],\r\n            ]\r\n        ];\r\n\r\n        var mapWidth = 256;\r\n\r\n        let rnd = m => ~~(Math.random() * m);\r\n\r\n        let pl = pieces.length;\r\n        for (let i = 0; i < pl; i++) {\r\n            let clone = pieces[i].slice();\r\n            for (let j = 0; j < clone.length; j++)\r\n                clone[j] = clone[j].slice().reverse();\r\n            pieces.push(clone);\r\n            let clone2 = pieces[i].slice();\r\n            clone2 = clone2.reverse();\r\n            pieces.push(clone2);\r\n            let clone3 = clone.slice();\r\n            clone3 = clone3.reverse();\r\n            pieces.push(clone3);\r\n        }\r\n        for (let i = 0; i < pieces.length; i++) {\r\n            pieces[i].size = { w: pieces[i][0].length, h: pieces[i].length };\r\n            pieces[i].exits = [];\r\n            for (let j = 0; j < pieces[i].size.h; j++) {\r\n                for (let h = 0; h < pieces[i].size.w; h++) {\r\n                    if (pieces[i][j][h] === 2) {\r\n                        pieces[i].exits.push({ x: h, y: j });\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        var mapCanvas = document.createElement('canvas');\r\n        mapCanvas.width = mapWidth;\r\n        mapCanvas.height = mapWidth;\r\n\r\n        //Temp during development\r\n        // mapCanvas.style.width = '1024px';\r\n        // mapCanvas.style.height = '1024px';\r\n        // mapCanvas.style.imageRendering = 'pixelated';\r\n        // document.body.appendChild(mapCanvas);\r\n        // document.body.style.backgroundColor = '#000';\r\n        //END\r\n\r\n        var mapContext = mapCanvas.getContext('2d');\r\n        mapContext.fillStyle = \"rgba(0, 0, 0, 0)\";\r\n        mapContext.fillRect(0, 0, mapWidth, mapWidth);\r\n\r\n        let first = true;\r\n        var addRoom = (exit, special) => {\r\n            let piece;\r\n            let exits = [];\r\n            let clear = false;\r\n            let targetX;\r\n            let targetY;\r\n            let tries = 25;\r\n            do {\r\n                piece = pieces[rnd(pieces.length)];\r\n                for (var q = 0; q < piece.exits.length; q++) {\r\n                    //calcalate new position so that the '2s' go on top of eachother, but tiles not overlap\r\n                    //if they overlap try a different '2'\r\n                    //if there isn't a 2, try another piece\r\n                    targetX = exit.x - piece.exits[q].x;\r\n                    targetY = exit.y - piece.exits[q].y;\r\n                    var imgData = mapContext.getImageData(targetX, targetY, piece.size.w, piece.size.h);\r\n                    clear = imgData.data.every(d => d === 0)\r\n                    if (clear) {\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                tries--;\r\n            } while (tries > 0 && !clear);\r\n            if (!clear) {\r\n                piece = [[1]];\r\n                piece.exits = [{}];\r\n                targetX = exit.x;\r\n                targetY = exit.y;\r\n                q = 0;\r\n                // return [];\r\n            }\r\n            mapContext.fillStyle = \"#4A4\";\r\n            if (!first) mapContext.fillRect(targetX + piece.exits[q].x || 0, targetY + piece.exits[q].y || 0, 1, 1);\r\n            mapContext.fillStyle = !first ? \"#888\" : \"#A44\";\r\n            if (special === 1) {\r\n                mapContext.fillStyle = \"#F0F\";\r\n            }\r\n            if (special === 2) {\r\n                mapContext.fillStyle = \"#0FF\";\r\n            }\r\n            first = false;\r\n            piece.forEach((i, py) => {\r\n                i.forEach((j, px) => {\r\n                    if (j === 1) {\r\n\r\n                        mapContext.fillRect(targetX + px, targetY + py, 1, 1);\r\n                    }\r\n                    if (j === 2) {\r\n                        exits.push({ x: targetX + px, y: targetY + py });\r\n                    }\r\n                })\r\n            });\r\n            return exits;\r\n        }\r\n        let loops = 10;\r\n        let exits = [{ x: mapWidth / 2, y: mapWidth / 2 }];\r\n        for (let i = 0; i < loops; i++) {\r\n            let newExits = [];\r\n            let special;\r\n            exits.forEach((exit, ind) => {\r\n                if (i == loops - 1 && ind == exits.length - ~~(exits.length / 3)) {\r\n                    special = 1;\r\n                }\r\n                if (i == loops - 1 && ind == ~~(exits.length / 3)) {\r\n                    special = 2;\r\n                }\r\n                let q = addRoom(exit, special);\r\n                newExits = newExits.concat(q);\r\n                special = 0;\r\n            });\r\n            exits = newExits;\r\n        }\r\n\r\n        return mapContext;\r\n    }\r\n\r\n}\r\nmodule.exports = generator;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/map2.js\n// module id = 2\n// module chunks = 0","AFRAME.registerGeometry('map', {\r\n    schema: {\r\n      vertices: {\r\n        default: ['-10 10 0', '-10 -10 0', '10 -10 0'],\r\n      }\r\n    },\r\n  \r\n    init: function (data) {\r\n      var geometry = new THREE.Geometry();\r\n      geometry.vertices = data.vertices.map(function (vertex) {\r\n          var points = vertex.split(' ').map(function(x){return parseInt(x);});\r\n          return new THREE.Vector3(points[0], points[1], points[2]);\r\n      });\r\n      geometry.computeBoundingBox();\r\n      geometry.faces.push(new THREE.Face3(0, 1, 2));\r\n      geometry.mergeVertices();\r\n      geometry.computeFaceNormals();\r\n      geometry.computeVertexNormals();\r\n      this.geometry = geometry;\r\n    }\r\n  });\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/comp-map.js\n// module id = 3\n// module chunks = 0"],"sourceRoot":""}